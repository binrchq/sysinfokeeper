#!/usr/bin/perl
use strict;
use warnings;
use PPI;
use GraphViz;

# 读取Perl代码文件
my $filename = 'inxi';  # 替换为你的Perl文件路径

# 解析Perl代码
my $document = PPI::Document->new($filename);
die "无法解析文件 '$filename'" unless $document;

# 查找所有的包声明
my $packages = $document->find('PPI::Statement::Package');

# 输出包声明以进行调试
my %package_map;
if ($packages) {
    foreach my $package (@$packages) {
        if ($package->isa('PPI::Statement::Package')) {
            my $package_name = $package->namespace;
            print "找到包声明: $package_name\n";
            my $start_line = $package->location->[0];
            $package_map{$start_line} = $package_name;
        } else {
            print "找到非预期的对象: $package\n";
        }
    }
} else {
    print "未找到任何包声明\n";
}

# 查找所有的子例程定义
my $subs = $document->find('PPI::Statement::Sub');
my %calls;
my %functions_in_packages;

if ($subs) {
    foreach my $sub (@$subs) {
        my $sub_name = $sub->name;
        my $sub_block = $sub->block;
        
        next unless $sub_block;  # 跳过没有代码块的子例程

        # 确定子例程所在的包
        my $line_number = $sub->location->[0];
        my $package_name = '';
        foreach my $start_line (sort { $b <=> $a } keys %package_map) {
            if ($line_number >= $start_line) {
                $package_name = $package_map{$start_line};
                last;
            }
        }

        # 记录子例程所属包
        if ($package_name) {
            push @{$functions_in_packages{$package_name}}, $sub_name;
        } else {
            push @{$functions_in_packages{'main'}}, $sub_name;
        }

        # 查找子例程中的所有方法调用
        my $calls_in_sub = $sub_block->find('PPI::Token::Word');
        if ($calls_in_sub) {
            foreach my $call (@$calls_in_sub) {
                my $call_name = $call->content;
                # 简单过滤掉非子例程调用的单词
                if ($call_name ne $sub_name && $call_name !~ /^\d/ && $call_name !~ /::/) {
                    # 使用完整的包名作为节点名称
                    my $full_call_name = $call_name;
                    my $call_line_number = $call->location->[0];
                    my $call_package_name = '';
                    foreach my $start_line (sort { $b <=> $a } keys %package_map) {
                        if ($call_line_number >= $start_line) {
                            $call_package_name = $package_map{$start_line};
                            last;
                        }
                    }
                    if ($call_package_name) {
                        $full_call_name = "$call_package_name\:\:$call_name";
                    }
                    $calls{"$package_name\:\:$sub_name"}{$full_call_name} = 1;
                }
            }
        }
    }
}

# 创建GraphViz对象，调整布局和图像大小
my $g = GraphViz->new(
    layout => 'circo',     # 尝试不同的布局算法 'dot', 'neato', 'twopi', 'circo', 'fdp'
    overlap => 'false',  # 避免节点重叠
    rankdir => 'TB',     # 从上到下布局
    node => { shape => 'box', style => 'filled', fillcolor => 'lightgrey' },
    edge => { color => 'blue' },
    size => "10,10",     # 图像尺寸（单位：英寸）
    ratio => 'compress', # 调整图像的长宽比
    nodesep => 0.5,      # 调整节点间距
    ranksep => 10.0       # 增加层级间距
);

# 添加节点和边
foreach my $package (keys %functions_in_packages) {
    $g->add_node($package, shape => 'ellipse', style => 'filled', fillcolor => 'lightblue');
    foreach my $sub_name (@{$functions_in_packages{$package}}) {
        my $full_sub_name = "$package\:\:$sub_name";
        $g->add_node($full_sub_name);
        $g->add_edge($package => $full_sub_name);
    }
}

foreach my $caller (keys %calls) {
    foreach my $callee (keys %{$calls{$caller}}) {
        $g->add_node($callee);
        $g->add_edge($caller => $callee);
    }
}

# 输出图形到SVG文件
$g->as_svg('call_graph.svg');

print "调用图已生成并保存为 'call_graph.svg'\n";